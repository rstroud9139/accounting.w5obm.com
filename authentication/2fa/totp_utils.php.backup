<?php

/**
 * Two-Factor Authentication Utilities
 * File: /authentication/totp_utils.php
 * Purpose: Complete 2FA implementation for W5OBM
 */

require_once __DIR__ . '/../include/dbconn.php';
require_once __DIR__ . '/../include/helper_functions.php';

/**
 * TOTP (Time-based One-Time Password) Utility Functions
 * RFC 6238 compliant implementation
 */

if (!function_exists('base32_decode')) {
    /**
     * Decode a base32 string
     */
    function base32_decode($data)
    {
        $data = strtoupper($data);
        $data = str_replace(array('=', ' ', "\t", "\r", "\n"), '', $data);

        $alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
        $output = '';
        $v = 0;
        $vbits = 0;

        for ($i = 0; $i < strlen($data); $i++) {
            $v = ($v << 5) | strpos($alphabet, $data[$i]);
            $vbits += 5;
            if ($vbits >= 8) {
                $output .= chr(($v >> ($vbits - 8)) & 255);
                $vbits -= 8;
            }
        }

        return $output;
    }
}

if (!function_exists('base32_encode')) {
    /**
     * Encode a string to base32
     */
    function base32_encode($data)
    {
        $alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
        $output = '';
        $v = 0;
        $vbits = 0;

        for ($i = 0; $i < strlen($data); $i++) {
            $v = ($v << 8) | ord($data[$i]);
            $vbits += 8;
            while ($vbits >= 5) {
                $output .= $alphabet[($v >> ($vbits - 5)) & 31];
                $vbits -= 5;
            }
        }

        if ($vbits > 0) {
            $output .= $alphabet[($v << (5 - $vbits)) & 31];
        }

        return $output;
    }
}

if (!function_exists('generateTOTPSecret')) {
    /**
     * Generate a random secret for TOTP
     */
    function generateTOTPSecret($length = 32)
    {
        try {
            $secret = random_bytes($length);
            return base32_encode($secret);
        } catch (Exception $e) {
            error_log("TOTP Secret generation error: " . $e->getMessage());
            // Fallback to less secure method
            $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            $secret = '';
            for ($i = 0; $i < $length; $i++) {
                $secret .= $chars[mt_rand(0, strlen($chars) - 1)];
            }
            return $secret;
        }
    }
}

if (!function_exists('generateTOTPCode')) {
    /**
     * Generate TOTP code
     */
    function generateTOTPCode($secret, $time = null)
    {
        if ($time === null) {
            $time = time();
        }

        try {
            $timeSlice = intval($time / 30);
            $secretKey = base32_decode($secret);

            if (!$secretKey) {
                throw new Exception("Invalid secret key");
            }

            $time = pack('N*', 0, $timeSlice);
            $hash = hash_hmac('sha1', $time, $secretKey, true);
            $offset = ord($hash[19]) & 0xf;

            $code = (
                ((ord($hash[$offset]) & 0x7f) << 24) |
                ((ord($hash[$offset + 1]) & 0xff) << 16) |
                ((ord($hash[$offset + 2]) & 0xff) << 8) |
                (ord($hash[$offset + 3]) & 0xff)
            ) % 1000000;

            return sprintf('%06d', $code);
        } catch (Exception $e) {
            error_log("TOTP Code generation error: " . $e->getMessage());
            return false;
        }
    }
}

if (!function_exists('verifyTOTPCodeWithSecret')) {
    /**
     * Verify TOTP code with secret and time tolerance
     */
    function verifyTOTPCodeWithSecret($secret, $code, $tolerance = 1)
    {
        $currentTime = time();

        // Check current time slice and adjacent ones for tolerance
        for ($i = -$tolerance; $i <= $tolerance; $i++) {
            $testTime = $currentTime + ($i * 30);
            $expectedCode = generateTOTPCode($secret, $testTime);

            if ($expectedCode && hash_equals($expectedCode, $code)) {
                return true;
            }
        }

        return false;
    }
}

if (!function_exists('verifyTOTPCode')) {
    /**
     * Verify TOTP code for a specific user
     */
    function verifyTOTPCode($user_id, $code)
    {
        global $conn;

        try {
            $stmt = $conn->prepare("SELECT two_factor_secret FROM auth_users WHERE id = ? AND two_factor_enabled = 1");
            $stmt->bind_param('i', $user_id);
            $stmt->execute();
            $result = $stmt->get_result()->fetch_assoc();
            $stmt->close();

            if (!$result || !$result['two_factor_secret']) {
                return false;
            }

            return verifyTOTPCodeWithSecret($result['two_factor_secret'], $code);
        } catch (Exception $e) {
            error_log("TOTP verification error: " . $e->getMessage());
            return false;
        }
    }
}

if (!function_exists('generateQRCodeURL')) {
    /**
     * Generate QR code URL for TOTP setup
     */
    function generateQRCodeURL($secret, $issuer = 'W5OBM', $accountName = '')
    {
        $issuer = urlencode($issuer);
        $accountName = urlencode($accountName);

        $otpauth = "otpauth://totp/$issuer:$accountName?secret=$secret&issuer=$issuer";

        // Using Google Charts API for QR code generation
        return "https://chart.googleapis.com/chart?chs=200x200&chld=M|0&cht=qr&chl=" . urlencode($otpauth);
    }
}

if (!function_exists('enableTwoFactorForUser')) {
    /**
     * Enable 2FA for a user
     */
    function enableTwoFactorForUser($user_id, $secret)
    {
        global $conn;

        try {
            $stmt = $conn->prepare("UPDATE auth_users SET two_factor_enabled = 1, two_factor_secret = ?, two_factor_setup_at = NOW() WHERE id = ?");
            $stmt->bind_param('si', $secret, $user_id);
            $result = $stmt->execute();
            $stmt->close();

            if ($result) {
                // Log the 2FA enable event
                if (function_exists('logActivity')) {
                    logActivity($user_id, 'two_factor_enabled', 'auth_users', $user_id, 'Two-factor authentication enabled');
                }
                return true;
            }

            return false;
        } catch (Exception $e) {
            error_log("Enable 2FA error: " . $e->getMessage());
            return false;
        }
    }
}

if (!function_exists('disableTwoFactorForUser')) {
    /**
     * Disable 2FA for a user
     */
    function disableTwoFactorForUser($user_id)
    {
        global $conn;

        try {
            $stmt = $conn->prepare("UPDATE auth_users SET two_factor_enabled = 0, two_factor_secret = NULL WHERE id = ?");
            $stmt->bind_param('i', $user_id);
            $result = $stmt->execute();
            $stmt->close();

            if ($result) {
                // Log the 2FA disable event
                if (function_exists('logActivity')) {
                    logActivity($user_id, 'two_factor_disabled', 'auth_users', $user_id, 'Two-factor authentication disabled');
                }
                return true;
            }

            return false;
        } catch (Exception $e) {
            error_log("Disable 2FA error: " . $e->getMessage());
            return false;
        }
    }
}

if (!function_exists('generateBackupCodes')) {
    /**
     * Generate backup codes for 2FA
     */
    function generateBackupCodes($count = 10)
    {
        try {
            $codes = array();

            for ($i = 0; $i < $count; $i++) {
                $code = bin2hex(random_bytes(4)); // 8 character hex code
                $codes[] = strtoupper(substr($code, 0, 4) . '-' . substr($code, 4));
            }

            return $codes;
        } catch (Exception $e) {
            error_log("Backup codes generation error: " . $e->getMessage());
            return array();
        }
    }
}

if (!function_exists('validateTOTPSecret')) {
    /**
     * Validate that a secret is properly formatted
     */
    function validateTOTPSecret($secret)
    {
        // Remove any whitespace
        $secret = preg_replace('/\s+/', '', $secret);

        // Check if it's valid base32
        if (!preg_match('/^[A-Z2-7]+$/', $secret)) {
            return false;
        }

        // Check minimum length (should be at least 16 characters for security)
        if (strlen($secret) < 16) {
            return false;
        }

        return true;
    }
}

if (!function_exists('userNeeds2FA')) {
    /**
     * Check if user needs 2FA verification
     */
    function userNeeds2FA($user_id)
    {
        global $conn;

        try {
            $stmt = $conn->prepare("SELECT two_factor_enabled FROM auth_users WHERE id = ?");
            $stmt->bind_param('i', $user_id);
            $stmt->execute();
            $result = $stmt->get_result()->fetch_assoc();
            $stmt->close();

            if (!$result || !$result['two_factor_enabled']) {
                return false;
            }

            // Check if device is trusted (if table exists)
            if (function_exists('tableExists') && tableExists('auth_trusted_devices')) {
                $device_token = $_COOKIE['trusted_device'] ?? null;
                if ($device_token && function_exists('isTrustedDevice') && isTrustedDevice($user_id, $device_token)) {
                    return false;
                }
            }

            return true;
        } catch (Exception $e) {
            error_log("Check 2FA requirement error: " . $e->getMessage());
            return false;
        }
    }
}

if (!function_exists('isTrustedDevice')) {
    /**
     * Check if device is trusted
     */
    function isTrustedDevice($user_id, $device_token)
    {
        global $conn;

        if (!function_exists('tableExists') || !tableExists('auth_trusted_devices')) {
            return false;
        }

        try {
            $stmt = $conn->prepare("
                SELECT id FROM auth_trusted_devices 
                WHERE user_id = ? AND device_token = ? AND expires_at > NOW()
            ");

            $stmt->bind_param('is', $user_id, $device_token);
            $stmt->execute();
            $result = $stmt->get_result()->fetch_assoc();
            $stmt->close();

            if ($result) {
                // Update last used
                $stmt = $conn->prepare("UPDATE auth_trusted_devices SET last_used_at = NOW() WHERE id = ?");
                $stmt->bind_param('i', $result['id']);
                $stmt->execute();
                $stmt->close();

                return true;
            }

            return false;
        } catch (Exception $e) {
            error_log("Trusted device check error: " . $e->getMessage());
            return false;
        }
    }
}

if (!function_exists('createTrustedDevice')) {
    /**
     * Create trusted device
     */
    function createTrustedDevice($user_id, $ip_address, $user_agent)
    {
        global $conn;

        if (!function_exists('tableExists') || !tableExists('auth_trusted_devices')) {
            return false;
        }

        try {
            $device_token = bin2hex(random_bytes(32));
            $device_name = function_exists('getBrowserInfo') ? getBrowserInfo($user_agent) : 'Unknown Device';
            $trusted_days = 30;
            $expires_at = date('Y-m-d H:i:s', time() + ($trusted_days * 24 * 60 * 60));

            $stmt = $conn->prepare("
                INSERT INTO auth_trusted_devices 
                (user_id, device_token, device_name, ip_address, user_agent, expires_at) 
                VALUES (?, ?, ?, ?, ?, ?)
            ");

            $stmt->bind_param('isssss', $user_id, $device_token, $device_name, $ip_address, $user_agent, $expires_at);
            $result = $stmt->execute();
            $stmt->close();

            if ($result) {
                // Set cookie for trusted device
                setcookie('trusted_device', $device_token, time() + ($trusted_days * 24 * 60 * 60), '/', '', true, true);
                return $device_token;
            }

            return false;
        } catch (Exception $e) {
            error_log("Create trusted device error: " . $e->getMessage());
            return false;
        }
    }
}

if (!function_exists('verifyBackupCode')) {
    /**
     * Verify backup code for 2FA
     */
    function verifyBackupCode($user_id, $code)
    {
        global $conn;

        try {
            // Check if backup codes table exists
            if (!function_exists('tableExists') || !tableExists('auth_backup_codes')) {
                return false;
            }

            $stmt = $conn->prepare("
                SELECT id FROM auth_backup_codes 
                WHERE user_id = ? AND code = ? AND used_at IS NULL
            ");

            $stmt->bind_param('is', $user_id, $code);
            $stmt->execute();
            $result = $stmt->get_result()->fetch_assoc();
            $stmt->close();

            if ($result) {
                // Mark code as used
                $stmt = $conn->prepare("UPDATE auth_backup_codes SET used_at = NOW() WHERE id = ?");
                $stmt->bind_param('i', $result['id']);
                $stmt->execute();
                $stmt->close();

                return true;
            }

            return false;
        } catch (Exception $e) {
            error_log("Backup code verification error: " . $e->getMessage());
            return false;
        }
    }
}

if (!function_exists('tableExists')) {
    /**
     * Check if a database table exists
     */
    function tableExists($tableName)
    {
        global $conn;

        try {
            $result = $conn->query("SHOW TABLES LIKE '$tableName'");
            return $result && $result->num_rows > 0;
        } catch (Exception $e) {
            return false;
        }
    }
}

if (!function_exists('getBrowserInfo')) {
    /**
     * Get simplified browser info from user agent
     */
    function getBrowserInfo($user_agent)
    {
        if (strpos($user_agent, 'Chrome') !== false) {
            return 'Chrome Browser';
        } elseif (strpos($user_agent, 'Firefox') !== false) {
            return 'Firefox Browser';
        } elseif (strpos($user_agent, 'Safari') !== false) {
            return 'Safari Browser';
        } elseif (strpos($user_agent, 'Edge') !== false) {
            return 'Edge Browser';
        } else {
            return 'Unknown Browser';
        }
    }
}
